 <!DOCTYPE html>
 <!--
Computación Gráfica:	Transformaciones
Por: 					Yecid Yamid Sánchez León
Dirigido a: 			Héctor Murcia Forero
-->
<html>
  <head>
    <title>Transformaciones</title>
    <style>
      html, body { margin: 0; padding: 0; overflow: hidden; }
      /*
	  Atributos CSS para el id="info".
      */
      #info {
          position: absolute;
          padding: 10px;
          width: 100%;
          text-align: center;
          color: #FFFFFF;
      }
    </style>
  </head>
  <body>
    <div id="info"><p id="transf">TRASLACIÓN</p>
          Usar flecha arriba y abajo para mover sobre eje Y<br/>
		  Usar flecha izquierda y derecha para mover sobre eje X<br/>
		  Usar tecla 'Inicio' y 'Fin' para mover sobre eje Z<br/>
		  Usar tecla NumPad5 ('Clear') para mover al origen<br/>
		  Usar 'R' para rotar, 'T' para trasladar y 'E' para escalar<br/>
    </div>
    <!-- Importación de la librería Three.js. -->   
    <script src="js/three.min.js"></script>
    <script>
    	//Creación de las variables escena, aspecto, cámara, render y acciones del teclado.
		var scene, aspect, camera, renderer;
		var startTime = Date.now();
		var leftArrow = false;
		var rightArrow = false;
		var upArrow = false;
		var downArrow = false;
		var clearKey = false;
		var homeKey = false;
		var endKey = false;
		var R_Key = false;
		var object, transf = 'T';
		//Ángulo expresado en radianes.
		var angulo = 1 * Math.PI / 100;
		var xAxis = true;
		var yAxis = false;
		var zAxis = false;

		//Declaración de las funciones de inicialización y animación.
		init();
		animate();
	
		function init() {
			scene = new THREE.Scene();
			aspect = window.innerWidth / window.innerHeight;
			camera = new THREE.PerspectiveCamera( 45, aspect, 0.1, 1000);
			renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );
				  			
			//Eventos del teclado.
			//Sentencias Switch para los casos TRUE.
			var onKeyDown = function ( event ) {
				switch ( event.keyCode ) {
					case 35: //Eventos en sentido -Z.
						endKey = true;
						break;
					case 36: //Eventos en sentido +Z.
						homeKey = true;
						break;
					case 37: //Eventos en sentido -X.
						leftArrow = true;
						break;
					case 38: //Eventos en sentido +Y.
						upArrow = true;
						break;
					case 39: //Eventos en sentido +X.
						rightArrow = true;
						break;
					case 40: //Eventos en sentido -Y.
						downArrow = true;
						break;
					case 12: //Ir al origen de coordenadas.
						clearKey = true;
						break;
					case 69: //Activar Escalado.
						transf = 'E';
						document.getElementById("transf").innerHTML = "ESCALADO";
						break;
					case 82: //Activar Rotación.
						transf = 'R';
						R_Key = true;
						document.getElementById("transf").innerHTML = "ROTACIÓN";
						break;
					case 84: //Activar Traslación.
						transf = 'T';
						document.getElementById("transf").innerHTML = "TRASLACIÓN";
						break;	
					//Rotación: Seleccionar el eje X.
					/*case 88:
						yAxis = false;
						zAxis = false;
						xAxis = true;
						break;
					//Rotación: Seleccionar el eje Y.
					case 89:
						xAxis = false;
						zAxis = false;
						yAxis = true;
						break;
					//Rotación: Seleccionar el eje Z.
					case 90:
						xAxis = false;
						yAxis = false;
						zAxis = true;
						break;	*/		
				}
		};	  
		  	
		//Sentencias para los casos FALSE.
		var onKeyUp = function ( event ) {
			upArrow = false;
			downArrow = false;
			leftArrow = false;
			rightArrow = false;
			clearKey = false;
			homeKey = false;
			endKey = false;
			R_Key = false;
			//Rotación: Hacia atrás.
			/*case 37:
				leftArrow = false;
				break;
			//Rotación: Hacia adelante.
			case 39:
				rightArrow = false;
				break;*/
		};	  	
		//Sentencia que notifica al navegador la interacción del usuario.
		//keydown: El usuario presiona una tecla.
		//keyup: El usuario libera la tecla.
		document.addEventListener( 'keydown', onKeyDown, false );
		document.addEventListener( 'keyup', onKeyUp, false );
			
		//Elementos de la escena.
		var size = 10;
		var arrowSize = 1;
		var divisions = size;
		//Vector unitario y punto de origen.
		var origin = new THREE.Vector3( 0, 0, 0 );
		var x = new THREE.Vector3( 1, 0, 0 );
		var y = new THREE.Vector3( 0, 1, 0 );
		var z = new THREE.Vector3( 0, 0, 1 );
		//color1: Para las grillas.
		var color1 = new THREE.Color( 0xFFFFFF );
		//color2: Para el fondo del escenario.
		var color2 = new THREE.Color( 0x333333 );
		//colorR, colorG, colorB: Para las Flechas de Coordenadas.
		var colorR = new THREE.Color( 0xAA3333 );
		var colorG = new THREE.Color( 0x33AA33 );
		var colorB = new THREE.Color( 0x333366 );
		//Colores de las caras del objeto 3D.
		var colorRd = new THREE.Color( 0xAA6666 );
		var colorGd = new THREE.Color( 0x66AA66 );
		var colorBd = new THREE.Color( 0x6666AA );
		  
		//Creación de las grillas del escenario.
		var axesHelper = new THREE.AxesHelper( size );
		var gridHelperXY = new THREE.GridHelper( size, divisions, color1, color1);
		var gridHelperXZ = new THREE.GridHelper( size, divisions, color2, color2 );
		var gridHelperYZ = new THREE.GridHelper( size, divisions, color2, color2 );
            
        //Rotarlas para que queden en el escenario adecuado.
        gridHelperXY.rotateOnWorldAxis ( x, THREE.Math.degToRad(90));
        gridHelperXZ.rotateOnWorldAxis ( y, THREE.Math.degToRad(90));
        gridHelperYZ.rotateOnWorldAxis ( z, THREE.Math.degToRad(90));
            
        //Creación de las Flechas de Coordenadas.
        var arrowX = new THREE.ArrowHelper( x, origin, arrowSize, colorR );
        var arrowY = new THREE.ArrowHelper( y, origin, arrowSize, colorG );
        var arrowZ = new THREE.ArrowHelper( z, origin, arrowSize, colorB );
			
		///Cración de cada una de las caras del cubo.
		var geometry = new THREE.BoxGeometry( 1, 1, 1 );

		for ( var i = 0; i < geometry.faces.length; i ++ ) {
			switch(i) {
				case 0: case 1: geometry.faces[ i ].color = colorRd; break;
				case 2: case 3: geometry.faces[ i ].color = colorRd; break;
				case 4: case 5: geometry.faces[ i ].color = colorGd; break;
				case 6: case 7: geometry.faces[ i ].color = colorGd; break;
				case 8: case 9: geometry.faces[ i ].color = colorBd; break;
				case 10: case 11: geometry.faces[ i ].color = colorBd; break;
			}				
		}
             
		//Creación de los materiales del Objeto 3D.
        var material = new THREE.MeshBasicMaterial( { color: color1, vertexColors: THREE.FaceColors } );
			
		///Creación del objeto.
		object  = new THREE.Mesh( geometry, material );
		
		//Agregamos el OBJETO 3D a la escena.
        scene.add( gridHelperXZ );
		scene.add( arrowX );	
		scene.add( arrowY );	
		scene.add( arrowZ );	
		scene.add( object );
			
		//Posicionamiento de la cámara.
		camera.position.x = 5;
		camera.position.y = 10;	 
		camera.position.z =  10;			
		camera.lookAt( origin );
	}
    
    //Definición de la función de animación.
    function animate() {
        render();
        requestAnimationFrame( animate );
    }
    
    //Definición de la función de renderizado.
    function render(){
        var dtime = Date.now()-startTime;
		var tx=0, ty=0, tz=0;
		if(transf == 'E') {
			tx=1; ty=1; tz=1;
		}
		if(upArrow) {
			ty = (transf == 'T' ? 1 : transf == 'E' ? 1.1 : transf == 'R' ? angulo : 0);
		}
		if(downArrow) {
			ty = (transf == 'T' ? -1 : transf == 'E' ? 10/11 : transf == 'R' ? -angulo : 0);
		}
		if(leftArrow) {
			tx = (transf == 'T' ? -1 : transf == 'E' ? 10/11 : transf == 'R' ? -angulo : 0);
		}
		if(rightArrow) {
			tx = (transf == 'T' ? 1 : transf == 'E' ? 1.1 : transf == 'R' ? angulo : 0);
		}
		if(homeKey) {
			tz = (transf == 'T' ? 1 : transf == 'E' ? 1.1 : transf == 'R' ? angulo : 0);
		}
		if(endKey) {
			tz = (transf == 'T' ? -1 : transf == 'E' ? 10/11 : transf == 'R' ? -angulo : 0);
		}
		if(clearKey) {
			tx=-object.position.x;
			ty=-object.position.y;
			tz=-object.position.z;
		}

		//Matrices de transformación.
		var t = new THREE.Matrix4();		
		var cos_g = Math.cos(angulo); 
		var sin_g = Math.sin(angulo);

		//Matriz de Traslación.
		if (transf == 'T')
			t.set( 	1, 0, 0, tx,
					0, 1, 0, ty, 
					0, 0, 1, tz,
					0, 0, 0, 1);
		//Matriz de Escalado.
		if (transf == 'E')
			t.set( 	tx, 0, 0, 0,
					0, ty, 0, 0, 
					0, 0, tz, 0,
					0, 0,  0, 1);
		//Matriz de Rotación.
		if (transf == 'R')
			t.set( 	1, 0, 		0, 		0,
					0, cos_g, 	-sin_g, 0, 
					0, sin_g, 	cos_g, 	0,
					0, 0, 		0, 		1);
		//Aplicar la matriz de transformación al objeto.
		object.applyMatrix(t);	
		//Avisar que la matriz del objeto ha cambiado.
		object.elementsNeedUpdate = true;	
        camera.lookAt( 0, 0, 0 );
        renderer.render( scene, camera );
    }
    </script>
  </body>
</html>